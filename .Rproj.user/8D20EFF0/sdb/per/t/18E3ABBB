{
    "contents" : "#' Illustration of partition density\n#' \n#' Calculate the average density of all resulting modules from a partition. The \n#' density of each module is defined as the average adjacency of the module \n#' genes.\n#' \n#' @param ADJ gene similarity matrix \n#' @param PartitionSet vector indicates the partition label for genes\n#' \n#' @return partition density, defined as average density of all modules\n#' \n#' @references Langfelder, Peter, and Steve Horvath. \"WGCNA: an R package for \n#' weighted correlation network analysis.\" BMC bioinformatics 9.1 (2008): 1.\n#' \n#' @author Dong Li, \\email{dxl466@cs.bham.ac.uk}\n#' @keywords density\n#' \n#' @examples\n#' data(synthetic)\n#' ADJ1=abs(cor(datExpr1,use=\"p\"))^10\n#' dissADJ=1-ADJ1\n#' hierADJ=hclust(as.dist(dissADJ), method=\"average\" )\n#' groups <- cutree(hierADJ, h = 0.8)\n#' pDensity <- PartitionDensity(ADJ1,groups) \n#' @export\n#' \nPartitionDensity <- function(ADJ, PartitionSet){\n    labels <- unique(PartitionSet)\n    numP <- length(labels)\n    pdensity <- 0\n    for (i in seq_len(numP)){\n        idx = which(PartitionSet == labels[i])\n        \n        if (length(idx) == 1){\n            pdensity <- pdensity + 0\n        }else{\n            Aq = ADJ[idx,idx]\n            sum = sum(Aq)\n            nrow = dim(Aq)[1]\n            pdensity <- pdensity + sum*(sum-nrow)/(nrow*nrow-nrow)\n        }\n        \n    }\n    pdensity <- pdensity*2/sum(ADJ)\n    pdensity\n}\n\n#' Illustration of modularity density\n#'\n#' Calculate the average modularity of a partition. The modularity of each \n#' module is defined from a natural generalization of unweighted case.\n#'\n#' @param ADJ gene similarity matrix \n#' @param PartitionSet vector indicates the partition label for genes\n#' \n#' @return partition modularity, defined as average modularity of all modules\n#' \n#' @references Newman, Mark EJ. \"Analysis of weighted networks.\" Physical \n#' review E 70.5 (2004): 056131.\n#' \n#' @author Dong Li, \\email{dxl466@cs.bham.ac.uk}\n#' @keywords modularity\n#' \n#' @examples\n#' data(synthetic)\n#' ADJ1=abs(cor(datExpr1,use=\"p\"))^10\n#' dissADJ=1-ADJ1\n#' hierADJ=hclust(as.dist(dissADJ), method=\"average\" )\n#' groups <- cutree(hierADJ, h = 0.8)\n#' pDensity <- PartitionModularity(ADJ1,groups) \n#' \n#' @export\n#'\nPartitionModularity <- function(ADJ, PartitionSet){\n    labels <- unique(PartitionSet)\n    numP <- length(labels)\n    pModularity <- 0\n    for (i in seq_len(numP)){\n        idx = which(PartitionSet == labels[i])\n        \n        if (length(idx) == 1){\n            pModularity <- pModularity + 0\n        }else{\n            Aq = ADJ[idx,idx]\n            sum = sum(Aq)\n            nrow = dim(Aq)[1]\n            pModularity <- pModularity + sum * (sum - nrow) / (nrow * (nrow - 1))\n        }\n        \n    }\n    pModularity <- pModularity*2/sum(ADJ)\n    pModularity\n}\n\n#' Illustration of Modules detection\n#' \n#' Module detection based on the optimal cutting height of dendrogram, which is \n#' selected to make the average density or modularity of resulting partition\n#' maximal. The clustering and visulization function are from WGCNA.\n#'\n#' @param datExpr gene expression profile, rows are samples and columns genes\n#' @param foldername where to store the clusters\n#' @param indicatename normally a specific tag of condition\n#' @param cutmethod cutting the dendrogram based on maximal average Density \n#' or Modularity\n#' @param power the power parameter of WGCNA, W_{ij}=|cor(x_i,x_j)|^power\n#'\n#' @return The number of clusters\n#' \n#' @references Langfelder, Peter, and Steve Horvath. \"WGCNA: an R package for \n#' weighted correlation network analysis.\" BMC bioinformatics 9.1 (2008): 1.\n#' \n#' @author Dong Li, \\email{dxl466@cs.bham.ac.uk}\n#' @keywords cutting dendrogram\n#' @seealso \\code{\\link{PartitionDensity}}\n#' @seealso \\code{\\link{PartitionModularity}}\n#' \n#' @import WGCNA\n#' @import igraph\n#' @importFrom dynamicTreeCut cutreeDynamic\n#' @examples\n#' data(synthetic)\n#' ResultFolder = 'ForSynthetic' # where middle files are stored\n#' CuttingCriterion = 'Density' # could be Density or Modularity\n#' indicator1 = 'X'     # indicator for data profile 1\n#' indicator2 = 'Y'      # indicator for data profile 2\n#' specificTheta = 0.1 #threshold to define condition specific modules\n#' conservedTheta = 0.1#threshold to define conserved modules\n#' intModules1 <- WeightedModulePartitionDensity(datExpr1,ResultFolder,\n#' indicator1,CuttingCriterion) \n\n#' @export\n#' \nWeightedModulePartitionDensity <- function(datExpr,foldername,indicatename,\n                        cutmethod=c('Density','Modularity'), power=10){\n    dir.create(file.path('./', foldername), showWarnings = FALSE)\n    \n    ADJ1=abs(cor(datExpr,use=\"p\"))^power\n    dissADJ=1-ADJ1\n    hierADJ=hclust(as.dist(dissADJ), method=\"average\" )\n    #NumCutHeights = 27440 for DaphIX, too much, just change\n    #NumCutHeights <- length(hierADJ$height)\n    cutHeights <- seq(0.05,1,by=0.05)\n    NumCutHeights <- length(cutHeights)\n    pDensity <- numeric(length <- NumCutHeights)\n    maxpDensity <- 0\n    maxHeight <- 0\n    for (i in 1:NumCutHeights) {\n        #groups <- cutree(hierADJ, h = hierADJ$height[i]) # cut tree into 5\n        groups <- cutree(hierADJ, h = cutHeights[i])\n        if (cutmethod == 'density'){\n            pDensity[i] <- PartitionDensity(ADJ1,groups)\n        }else{\n            pDensity[i] <- PartitionModularity(ADJ1,groups)\n        }\n        \n        if (pDensity[i] > maxpDensity){\n            maxpDensity <- pDensity[i]\n            maxHeight <- cutHeights[i]\n        }\n    }\n\n    # We like large modules, so we set the minimum module size relatively high:\n    minModuleSize = 30;\n    # Module identification using dynamic tree cut:\n    dynamicMods = cutreeDynamic(dendro = hierADJ, distM = dissADJ, cutHeight = \n                            maxHeight,deepSplit = 2, pamRespectsDendro = FALSE,\n                            minClusterSize = minModuleSize)\n    \n    dynamicColors = labels2colors(dynamicMods)\n    intModules = table(dynamicColors)\n     \n    #######Visualization#############\n    pdf(paste(foldername,\"/Partitions_\",indicatename,\".pdf\",sep=\"\"),width = 11, \n        height = 8)\n    marAll = c(1, 5, 3, 1)\n    layout(matrix(c(1,2,3,0), 2, 2, byrow = TRUE), widths=c(0.8,0.2),\n           heights=c(0.8,0.2))\n    par(mar = c(0, marAll[2], marAll[3], marAll[4]))\n    plot(hierADJ, labels = FALSE, xlab=\"\", sub=\"\", ylim=c(0,1),hang = -1,\n         axes=FALSE,main = \"Gene hierarchical clustering dendrogram\")\n    abline(h = maxHeight, col = 'red')\n    axis(side = 2, at = seq(1,0,-0.2),labels =seq(1,0,-0.2))\n    par(mar = c(0, 1, marAll[3], marAll[4]),mgp = c(0, 1, 0))\n    plot(pDensity, cutHeights, type = 'n', ylim=c(0,1), axes=FALSE,ylab = \"\")\n    title(paste('Average',cutmethod), font.main = 1, cex.main = 1,line  = 0)\n    axis(side = 1, at\t= seq(0,(max(pDensity)+0.1),0.1),\n         labels = seq(0,(max(pDensity)+0.1),0.1))\n    axis(side = 2, at\t= seq(1,0,-0.2),labels =seq(1,0,-0.2))\n    lines(pDensity, cutHeights, lwd = 2, col = 'blue')\n    abline(h = maxHeight, col = 'red')\n    par(mar = c(marAll[1], marAll[2], 0, marAll[4]))\n    plotColorUnderTree(hierADJ, dynamicColors, groupLabels = NULL, \n                       rowText = NULL, rowLabels = 'Clusters')\n    dev.off()\n    \n    for(J in 1:length(intModules)){\n        idx <- which(dynamicColors == names(intModules)[J])\n        DenseGenes = colnames(datExpr)[idx]\n        densegenefile <- paste(foldername,\"/DenseModuleGene_\",\n                               indicatename,\"_\",J,\".txt\",sep=\"\")\n        write.table(DenseGenes,densegenefile,sep = \"\\n\",col.names = FALSE,\n                    row.names = FALSE,quote = FALSE)\n    }\n    \n    return (length(intModules))\n}\n\n#' Illustration of two networks comparison\n#' \n#' Compare the background network and a condition-specific network. A Jaccard\n#' index is used to measure the similarity of two sets, which represents the \n#' similarity of each module pairs from two networks.\n#'\n#' @param sourcehead prefix of where to store results\n#' @param nm1 how many modules in the background network\n#' @param nm2 how many modules in the condition-specific network\n#' @param ind1 indicator of the background network\n#' @param ind2 indicator of the condition-specific network\n#'\n#' @return A matrix where each entry is the Jaccard index of corresponding \n#' modules from two networks\n#' \n#' @author Dong Li, \\email{dxl466@cs.bham.ac.uk}\n#' @keywords module comparison\n#' \n#' @examples\n#' data(synthetic)\n#' ResultFolder = 'ForSynthetic' # where middle files are stored\n#' CuttingCriterion = 'Density' # could be Density or Modularity\n#' indicator1 = 'X'     # indicator for data profile 1\n#' indicator2 = 'Y'      # indicator for data profile 2\n#' intModules1 <- WeightedModulePartitionDensity(datExpr1,ResultFolder,\n#' indicator1,CuttingCriterion) \n#' intModules2 <- WeightedModulePartitionDensity(datExpr2,ResultFolder,\n#' indicator2,CuttingCriterion) \n#' JaccardMatrix <- comparemodulestwonets(ResultFolder,intModules1,intModules2,\n#' paste('/DenseModuleGene_',indicator1,sep=''),\n#' paste('/DenseModuleGene_',indicator2,sep=''))\n#' \n#' @export\n#' \ncomparemodulestwonets <- function(sourcehead,nm1,nm2,ind1,ind2){\n    my.array<-array(0,dim=c(nm1,nm2))\n    for(i1 in 1:nm1){\n        for (i2 in 1:nm2){\n            # sourcehead = \"Networks/DenseModuleGene_\"\n            densegenefile1 <- paste(sourcehead,ind1,\"_\",i1,\".txt\",sep=\"\")\n            densegenefile2 <- paste(sourcehead,ind2,\"_\",i2,\".txt\",sep=\"\")\n            list1 <- readLines(densegenefile1)\n            list2 <- readLines(densegenefile2)\n            my.array[i1,i2] = length(intersect(list1,list2))/\n                length(union(list1,list2))\n        }\n    }\n    return (my.array)\n}\n\n#' Illustration of network comparison\n#' \n#' Compare the background network and a set of condition-specific network. \n#' Conserved or condition-specific modules are indicated by the plain files, \n#' based on the statistics \n#'\n#' @param ResultFolder where to store results\n#' @param intModules how many modules in the background network\n#' @param speciesName identifier of current profile, served as a tag in name\n#' @param intconditionModules a numeric vector, each of them is the number \n#' of modules in each condition-specific network. Or just single number\n#' @param conditionNames a character vector, each of them is the name \n#' of condition. Or just single name\n#' @param specificTheta the threshold to define min(s)+specificTheta, \n#' less than which is considered as condition specific module. \n#' s is the sums of rows in Jaccard index matrix. See supplementary file. \n#' @param conservedTheta The threshold to define max(s)-conservedTheta, \n#' greater than which is considered as condition conserved module. \n#' s is the sums of rows in Jaccard index matrix. See supplementary file.\n#'\n#' @return None\n#' \n#' @author Dong Li, \\email{dxl466@cs.bham.ac.uk}\n#' @seealso \\code{\\link{WeightedModulePartitionDensity}},\n#' \\code{\\link{comparemodulestwonets}}\n#' @keywords module differential\n#' \n#' @examples\n#' data(synthetic)\n#' ResultFolder = 'ForSynthetic' # where middle files are stored\n#' CuttingCriterion = 'Density' # could be Density or Modularity\n#' indicator1 = 'X'     # indicator for data profile 1\n#' indicator2 = 'Y'      # indicator for data profile 2\n#' specificTheta = 0.1 #threshold to define condition specific modules\n#' conservedTheta = 0.1#threshold to define conserved modules\n#' intModules1 <- WeightedModulePartitionDensity(datExpr1,ResultFolder,\n#' indicator1,CuttingCriterion) \n#' intModules2 <- WeightedModulePartitionDensity(datExpr2,ResultFolder,\n#' indicator2,CuttingCriterion) \n#' CompareAllNets(ResultFolder,intModules1,indicator1,intModules2,indicator2,\n#' specificTheta,conservedTheta)\n#' \n#' @export\n#' \nCompareAllNets <-function(ResultFolder,intModules,speciesName,\n                          intconditionModules,conditionNames,specificTheta,\n                          conservedTheta){\n    for (i in 1:length(conditionNames)) {\n        ArrayGroup1 <- comparemodulestwonets(ResultFolder,intModules,\n                    intconditionModules[i],paste('/DenseModuleGene_',\n                    speciesName,sep=''),paste('/DenseModuleGene_',\n                    conditionNames[i],sep=''))\n        dir.create(paste(ResultFolder,'/',conditionNames[i],sep=''))\n        fileprefix <- paste(ResultFolder,'/',conditionNames[i],'/',sep='')\n\n        pdf(paste(fileprefix,'module_overlap_remove',conditionNames[i],\n                  '.pdf',sep=''),width = 10, height = 8)\n        plot(1:intModules,rowSums(ArrayGroup1),xlim = c(0,(intModules + 1)),\n             ylim = c(0,max(rowSums(ArrayGroup1)) + 0.1),\n             xlab=\"Module ID\",ylab = 'RowSums of jaccard matrix', \n             type = 'n',main=\"Overlapped ratio\")\n        lines(1:intModules, rowSums(ArrayGroup1), col = 'black', type = \"b\")\n        abline(h = min(rowSums(ArrayGroup1)) + 0.1, col='red')\n        abline(h = max(rowSums(ArrayGroup1)) - 0.1, col='green')\n        text(5, min(rowSums(ArrayGroup1)) - 0.05, \"condition response\", \n             col = \"red\",cex = 0.75)\n        text(5, max(rowSums(ArrayGroup1)) + 0.05, \"conserved response\", \n             col = \"green\",cex = 0.75)\n        dev.off()\n        specificmoduleid <- which(rowSums(ArrayGroup1) <= \n                                min(rowSums(ArrayGroup1)) + specificTheta)\n        conservedmoduleid <- which(rowSums(ArrayGroup1) >= \n                                max(rowSums(ArrayGroup1)) - conservedTheta)\n        write.table(specificmoduleid,file = paste(fileprefix,\n                    'sepcificModuleid.txt',sep=''),\n                    row.names = FALSE, col.names = FALSE)\n        write.table(conservedmoduleid,file = paste(fileprefix,\n                    'conservedModuleid.txt',sep=''),\n                    row.names = FALSE, col.names = FALSE)\n    }\n}\n\n#' datExpr1\n#' \n#' Synthetic gene expression profile with 20 samples and 500 genes.\n#'\n#' @name datExpr1\n#' @docType data\n#' @author Dong Li, \\email{dxl466@cs.bham.ac.uk}\n#' @keywords data\n#' @format A matrix with 20 rows and 500 columns.\n#' @examples\n#' data(synthetic)\n#' ## plot the heatmap of the correlation matrix ...\n#' \\dontrun{heatmap(cor(as.matrix(datExpr1)))}\nNULL\n\n#' datExpr2\n#' \n#' Synthetic gene expression profile with 25 samples and 500 genes.\n#'\n#' @name datExpr2\n#' @docType data\n#' @author Dong Li, \\email{dxl466@cs.bham.ac.uk}\n#' @keywords data\n#' @format A matrix with 25 rows and 500 columns.\n#' @examples\n#' data(synthetic)\n#' ## plot the heatmap of the correlation matrix ...\n#' \\dontrun{heatmap(cor(as.matrix(datExpr2)))}\nNULL",
    "created" : 1464171308496.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "110853034",
    "id" : "18E3ABBB",
    "lastKnownWriteTime" : 1466609471,
    "path" : "D:/Code/MODA/R/MODA.R",
    "project_path" : "R/MODA.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}